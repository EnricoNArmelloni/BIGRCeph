
Please send issues and questions to: <enrico.e.armelloni@gmail.com>

# Description

The repository contains the data and code supporting the manuscript
“BIGRCeph: A Bayesian Hierarchical Model for Instantaneous Growth Rate
of Cephalopods - Application to published aquaculture experimental data
for sub-adult Common cuttlefish (*Sepia officinalis* Linnaeus, 1758)
under varying temperature and food conditions”.

The code and the models here reported serves to (i) fit model variants
for the instantaneous growth rate of cephalopods to data gathered from
published aquaculture experiments (target species = *Sepia officinalis*)
by applying Bayesian Hierarchical Models (ii) use MCMC posterior draws
to make inference

## Data

The folder “data” contains files included in the manuscript
supplementary materials and some other files generated by code provided
in this repository. The essential files needed to start the analysis
are:

- st1_experimental_details.csv summarizes the details of the
  experiments, as described in the manuscript. This file is needed in
  the script Step1
- st2_sample_info.csv contains all the data available in the
  experiments, as described in the manuscript.. This file is needed in
  the script Step2
- diet_info.csv contains the formatted information associated to each
  experiment regarding prey type, prey amount (procedure described in
  the manuscript) and temperature. This file is needed in the script
  Step 1.

All the other files contained in the folders are generated with the R
scripts provided in this repository. In particular:

- input data is the result of the script “step1”. It includes all the
  data of the file st2_sample_info.csv, plus the estimation of missing
  information based on algorithms described in Appendix A

- M1_model_data is a subset of input_data.csv and contains additional
  indexing columns. It is generated by the Step_2 R code

- M2_model_data is a subset of input_data.csv and contains additional
  indexing columns. It is generated by the Step_2 R code

## Code

### sub-folder R

Contains the code used to perform the analysis. The scripts to replicate
results are named with logic order (step1, step2 etc.). Each file
contains a short note describing the purpose of the code.
*supporting_functions.R* file contains custom functions that are used in
the other scripts. *Appendix_S1.R* contains the code used for the
simulation study described in Appendix_A

### sub-folder stan

Contains all the stan models for model variants described in the
manuscript. Stan files requires compilation, which create large files.
This repo only hosts the compiled files for the best model variants to
limit the folder size.

# Fit models

Script: step2_models.R

Dependencies: cmdstanr R package

Model variants described in the manuscript are stored in the *stan*
folder, and can be opened and edited with text editors. These models are
fit to data in R environment, through the script *step2_models.R*. The
input needed to fit stan models are:

- a compiled .stan model.

Models are compiled with the function cmdstan_model. See example at
lines 90-104

    M1_4_J.mod <-  cmdstan_model(file.path( models.dir, 'M14J.stan'))

- input data

In stan, input data must contain the data used to fit the models. In our
case, we also specify parameter priors.

    data.M1= list(N = nrow(y.dat), 
                                   y = as.numeric(y.dat$igr.mu),
                                   t= as.numeric(y.dat$t),
                                   R=as.numeric(y.dat$z1),
                                   tem=as.numeric(y.dat$z2),
                                   Npop =length(x.id.e),
                                   Ndiet =length(x.id.food), #
                                   Index=y.dat$Index.e,
                                   z=y.dat$Index.food, #
                                   obs_error_i=y.dat$igr.sd,
                                   nsamp=sqrt(y.dat$nsamp),
                                   # prior for mu and sigma when is shared
                                   pr_mean_mu=log(20), pr_mean_mu_sd=log(1.5),
                                   pr_mean_sigma= log(15), pr_mean_sigma_sd=log(10),
                                   # prior for mu and sigma when hierarchical
                                   pr_hyper_mu=20, pr_hyper_mu_sd=2.5,
                                   pr_hyper_mu_deviation=1.5,pr_hyper_mu_deviation_sd=0.5,
                                   pr_hyper_sigma=15,   pr_hyper_sigma_sd=10,
                                   pr_hyper_sigma_deviation=1.5,pr_hyper_sigma_deviation_sd=0.5,
                                   # priors for covariates
                                   pr_a=log(1), pr_a_sd= 0.5, # updated
                                   pr_bpow=log(1), pr_bpow_sd=0.5,
                                   pr_bquad=log(1),pr_bquad_sd=0.5,
                                   pr_diet=0, pr_diet_sd=1, 
                                   # prior for observation error
                                   pr_sigma_obs=5, pr_sigma_obs_sd=3)

- model initial values (optional)

Initial values should be specified as a list, where each element
correspond to the initial value of a parameter. The initial values can
be specified just for a few parameters. In case initial values are
specified for a random effect, the element should be a vector (e.g.:
here sigma is treated as a random effect)

     x.init=list('sigma'=rep(20,length(x.id.e)+1),
                    'mean_sigma'=20,
                    'sigma_sigma'=6,
                    'log_mu'=2,
                    'sigma_obs'=3,
                    'log_b1'=0,
                    'log_b2'=1.2)

In the code we provide, we built a loop to iterate over model variants,
where *x.mod* is a compiled stan model (e.g. *M1_4_J.mod*). Models are
fit by applying the following function:

        x.fit <- x.mod$sample(iter_warmup = 5000, 
                              iter_sampling = 5000,
                              data = data.M1,
                              seed = 123,
                              chains = 4,
                              parallel_chains = 4,
                              adapt_delta = 0.95,
                              thin=10,
                              max_treedepth=15,
                              init = list(x.init,x.init,x.init,x.init),
                              show_exceptions = F) 
                              

Importantly, model outputs should be saved for being re-used

    x.fit$save_output_files(dir = save.dir, 
                               basename = x.name, timestamp = FALSE, random = FALSE)
    saveRDS(x.fit, file.path(save.dir, paste0(x.name, '_fit.RDS')))

# Predict Instantaneous Growth Rate (IGRt)

Script: predict_IGRt.R

Dependencies: tidyverse R package; functions contained in the script
“supporting_functions.R”

MCMC draws from the best model variants can be used to predict IGRt as a
function of time, temperature, food amount and food type.

## Preparing data

The best model variant output can be loaded as

    best.M1=readRDS(file.path(model.dir, 'M1_4_J_fit.RDS'))

Subsequently, we extract MCMC draws by applying a customised function
that takes as input the stan model and has as output a dataframe, where
each column represents a vector of the 4 MCMC chain draws for a
parameter

    format.posteriors=function(x.model){
      x.post=x.model$draws()
      x.post=as.data.frame(x.post)
      x.post=x.post[,-grep('y.rep', names(x.post))]
      x.post=x.post[,-grep('raw', names(x.post))]
      x.post=x.post[,-grep('log_lik', names(x.post))]
      x.post=x.post[,-grep('lp_', names(x.post))]
      x.vars=unique(substr(names(x.post),3, nchar(names(x.post))))
      n.chain=ncol(x.post)/length(x.vars)
      x.post.matrix=matrix(ncol = length(x.vars), nrow=nrow(x.post)*n.chain)
      for(i in 1:length(x.vars)){
        x.post.matrix[,i]=as.numeric(unlist(x.post[,substr(colnames(x.post),3, nchar(colnames(x.post)))==x.vars[i]]  ))
      }
      x.post.matrix=as.data.frame(x.post.matrix)
      names(x.post.matrix)=x.vars
      return(x.post.matrix)
    }

    ### get posteriors 
    M1.posteriors=format.posteriors(best.M1)
    M2.posteriors=format.posteriors(best.M2)

The stan models are fit to normalised values for Temperature and Food.
We an create correspondence between the original and the normalised
values as

    temp.vec=data.frame(temp=seq(12.5,27, length.out=1000),
                        z2=seq(0, 1, length.out=1000))
    temp.vec$temp=round(temp.vec$temp, 2)

    food.vec=data.frame(Rcomma=seq(0,1.66, length.out=166),
                        z1=seq(0, 1, length.out=166))
    food.vec$Rcomma=round(food.vec$Rcomma, 2)

Also, we need to define correspondence between food types and the
indices used in the stan models

    ### get input data
    M1.data=read_csv("data/M1_model_data.csv")
    M2.data=read_csv("data/M2_model_data.csv")

    ## match fits index with food items
    index.F.M1=distinct(M1.data, Index.food, main_prey)
    index.F.M2=distinct(M2.data, Index.food, main_prey)

## Inference

Required setting to make inerence are

    time.vec=seq(0,120,5)
    experimental.temperature=18
    proportion.libitum=0.8
    prey='medium_shrimp'

Predictions are iterated over the vector of times separately for M1 and
M2

    # predictions for M1 and M2

    M1=function(a,b1,b2,b3,sigma,mu,t,tem,R,Fi){
      T_t=tem+0.5
      resp= (a * (R*Fi)^b1* (b2*T_t+b3*T_t^2)) * exp(-(t - mu)^2 / ( 2 * sigma^2))
      return(resp)
    }
    M2=function(A,b1,b4a,b2,b3,B,C,t,tem,R,Fi){
      T_t=tem+0.5
      resp=A*(T_t^b4a)*(R*Fi)^b1 + (B*(b2*T_t + b3*T_t^2) * (R*Fi)^b1) * exp(-t * C)
      return(resp)
    }

    m1.store=matrix(nrow = nrow(M1.posteriors), ncol=length(time.vec))
    m2.store=matrix(nrow = nrow(M2.posteriors), ncol=length(time.vec))
    for(i in 1:length(time.vec)){  
      m1.pred=data.frame(pred=M1(a=M1.posteriors$a,
                                   b1=M1.posteriors$bF,
                                   b2=M1.posteriors$bT1,
                                   b3=M1.posteriors$bT2,
                                   sigma=M1.posteriors$`sigma[28]`,
                                   mu=M1.posteriors$mu,
                                   t=time.vec[i],
                                   tem=temp.vec[temp.vec$temp==experimental.temperature,]$z2,
                                   Fi=M1.posteriors[,paste0('F[',index.F.M1[index.F.M1$main_prey==prey,]$Index.food,']')],
                                   R=food.vec[food.vec$Rcomma==proportion.libitum,]$z1))
      m1.pred$pred=as.numeric(mapply(function(mu, sigma) rnorm(n = 1, mean = mu, sd = sigma), m1.pred$pred, 
                                       apply(M1.posteriors[,grep('obs_erro', names(M1.posteriors))],1,mean)))
      m1.store[,i]=m1.pred$pred
        
      m2.pred=data.frame(pred=M2(A=M2.posteriors$A,
                                   b1=M2.posteriors$bF,
                                   b4a=M2.posteriors$bTA,
                                   b2=M2.posteriors$bTB1,
                                   b3=M2.posteriors$bTB2,
                                   B=M2.posteriors$`B[39]`,
                                   C=M2.posteriors$C,
                                   t=time.vec[i],
                                   tem=temp.vec[temp.vec$temp==experimental.temperature,]$z2,
                                   Fi=M2.posteriors[,paste0('F[',index.F.M2[index.F.M2$main_prey==prey,]$Index.food,']')],
                                   R=food.vec[food.vec$Rcomma==proportion.libitum,]$z1))
      m2.pred$pred=as.numeric(mapply(function(mu, sigma) rnorm(n = 1, mean = mu, sd = sigma), m2.pred$pred, 
                                       apply(M2.posteriors[,grep('obs_erro', names(M2.posteriors))],1,mean)))
      m2.store[,i]=m2.pred$pred
        
      }
    m1.store=as.data.frame(m1.store)
    names(m1.store)=paste0('t', time.vec)
    m2.store=as.data.frame(m2.store)
    names(m2.store)=paste0('t', time.vec)

Subsequently, predictions are spliced as

    sigmoid_transition <- function(t, m1,m2, x1,x2, k, type='sigm') {
      if(type=='sigm'){
        # Define Gaussian and Exponential functions
        # Sigmoid transition function
        phi0=data.frame(t=t,phi=NA)
        phi0$phi=ifelse(phi0$t<x1,0,
                        ifelse(phi0$t>x2,1,
                               1 / (1 + exp(-0.25 * (t - (x1+x2)/2)))))
        phi=phi0$phi
        # Combine functions with sigmoid transition
        (1 - phi) * m1 + phi * m2 
        
      }else{
        phi <- pmax(pmin((t - (x - k)) / (2 * k), 1), 0)
        # Combine functions with smooth transition
        ifelse(t < x - k, mj,
               ifelse(t > x + k, m2,
                      (1 - phi) * m1 + phi * m2))
      }
    }

    apply_sigmoid_row <- function(row1, row2, t_values) {
      mapply(function(m1, m2, t) {
        sigmoid_transition(t = t, m1 = m1, m2 = m2, x1 = 16, x2 = 41, k = 0.2)
      }, row1, row2, t_values)
    }

    m.comb=as.data.frame(apply_sigmoid_row(m1.store,m2.store,time.vec))

Data can be formatted for visualisation purposes

    # format for plotting
    Mcomb.resp=m.comb%>%
      dplyr::mutate(Temperature=experimental.temperature)%>%
      pivot_longer(-c(Temperature), names_to = 't', values_to = 'IGR')%>%
      dplyr::mutate(t=as.numeric(str_remove(t,'t')))%>%
      dplyr::group_by(t,Temperature)%>%
      dplyr::summarise(IGR.mu=mean(IGR, probs=c(0.5)),
                       IGR.lo=quantile(IGR, probs=c(0.1)),
                       IGR.hi=quantile(IGR, probs=c(0.9)))


    ggplot(data=Mcomb.resp, aes(x=t, y=IGR.mu))+
      geom_point()+
      geom_line()+
      geom_ribbon(aes(ymin=IGR.lo, ymax=IGR.hi),
                  alpha=0.2)+
      theme_minimal()+
      ylab('IGR (%bw*day-1')+
      xlab('Time (DAH)')+
      theme(legend.position = 'bottom')
      

<figure>
<img src="results/plots/example_plot.jpeg?raw=true" title="Title"
alt="Figure 1: discrete predictions of Instantaneous Growth Rate, with water temperature = 18 °, food amount = 0.8 * libitum, food type = medium shrimps (grass shrimps)" />
<figcaption aria-hidden="true">Figure 1: discrete predictions of
Instantaneous Growth Rate, with water temperature = 18 °, food amount =
0.8 * libitum, food type = medium shrimps (grass shrimps)</figcaption>
</figure>
